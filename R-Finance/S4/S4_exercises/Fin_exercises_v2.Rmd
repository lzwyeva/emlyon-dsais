---
title: "Financial Data Science Exercises"
output: 
  html_notebook:
    toc: true
    toc_float: true
---

**IMPORTANT NOTE**: the tasks are **sequential**. Consequently, PART II must be done after PART I, etc. New columns are progressively added to the dataset.

## DATA  

The data (file *data.RData*) consists of monthly financial information pertaining to 30 large US firms. They are characterised by their ticker:  

|A - F| G - M |O - Z|
| --- | ----- | --- |
| **AAPL** (Apple)| **GE** (General Electric) | **ORCL** (Oracle)
| **BA** (Boeing) | **HD** (Home Depot) | **PFE** (Pfizer)
| **BAC** (Bank of America) | **IBM** | **PG** (Procter & Gamble)
| **C** (Citigroup) | **INTC** (Intel) | **T** (AT&T)
| **CSCO** (Cisco) | **JNJ** (Johnson & Johnson) |  **UNH** (United Health)
| **CVS** (CVS Health) | **JPM** (JP Morgan) | **UPS** 
| **CVX** (Chevron) | **K** (Kellogg) | **VZ** (Verizon)
| **D** (Dominion Energy) | **MCK** (McKesson) | **WFC** (Wells Fargo)
| **DIS** (Disney) | **MRK** (Merck) | **WMT** (Walmart)
| **F** (Ford) | **MSFT** (Microsoft) | **XOM** (Exxon)


There are 7 attributes:      
- closing price (**Close**),     
- past (realized) 1 month volatility (**Vol_1M**),     
- market capitalisation in M$ (**Mkt_Cap**),     
- price-to-book ratio (**P2B**),     
- debt-to-equity (**D2E**),    
- profitability margin (**Prof_Margin**),    
- ESG ranking (**ESG_rank** from Sustainalytics, in %).    

Finally, the time range is end of 1999 to beginning of 2021.

***
## PART I: GRAPHS  

We start by exploring the dataset (visually) with some **simple plots**.

0) Load the data ('data.RData') and the *tidyverse* package.
```{r}
library(tidyverse) # load tidyverse package
load("data.RData") # load data.RData file
```

1) First, take a look at the data using the head() function and then the summary() function.
```{r}
head(data)
```

```{r}
head(data)
summary(data)
```

2) Plot (with a line) the price of the Microsoft (MSFT) share through time (this requires a filter first).
```{r}
library(ggplot2)
# filter for Microsoft (MSFT) share
msft_data <- data %>% filter(Tick == "MSFT")

# plot price through time
ggplot(msft_data, aes(x = Date, y = Close)) + 
  geom_line() +
  labs(title = "Microsoft (MSFT) Share Price through Time", x = "Date", y = "Price")

```

3) Plot (with a line) the price of Apple (AAPL), IBM and Microsoft with one color for each company.  
Obviously, there is a scale problem: we'll try to solve it in the next section.


```{r UP TO YOU! 1, message = FALSE, warning = FALSE}
library(ggplot2)

# filter data for Apple (AAPL), IBM, and Microsoft shares
aapl_data <- data %>% filter(Tick == "AAPL")
ibm_data <- data %>% filter(Tick == "IBM")
msft_data <- data %>% filter(Tick == "MSFT")

# combine data into a single data frame
combined_data <- rbind(aapl_data, ibm_data, msft_data)

# plot share prices with different colors
ggplot(combined_data, aes(x = Date, y = Close, color = Tick)) +
  geom_line() +
  labs(title = "Share Prices of Apple, IBM, and Microsoft", x = "Date", y = "Price", color = "Company")

```


***
## PART II: DATA WRANGLING
### Simple filters
1) Filter the data to keep only IBM figures. 
2) Filter the data to keep only year 2018. 
3) Do both at the same time.

```{r UP TO YOU! 2}
# Filter to keep only IBM figures
ibm_data <- data %>% filter(Tick == "IBM")

# Filter to keep only year 2018
ibm_data_2018 <- ibm_data %>% filter(year(Date) == 2018)

# Filter to keep only IBM figures for year 2018
ibm_data_2018_alt <- data %>% filter(Tick == "IBM", year(Date) == 2018)

```

### Modifying data: normalised prices

*The aim of this subsection is to add a new column to the "data" dataframe. This column would be equal to stock prices that are normalised to one on the first date. This makes graphical comparison across firms easier. This could be done with a loop - which would be ugly. We proceed otherwise for pedagogical purposes: use the --tidyverse!--*   

1) From the dataset, group according to firm names (Tick) and create a new column with **mutate**(), called "*First_price*" which is the first value of the column "*Close*". Remember, indexing is simple; v[1] is the first value of vector v.   
2) Finally, create a new *New_close* column (normalised close price), which is the Close divided by First_price.  
3) Plot (with a line) the *New_close* values of Apple, IBM and Microsoft (MSFT) with one color for each company.
4) Add a scale_y_log10() to reduce discrepancies. 

```{r UP TO YOU! 3}
# Group by Tick (i.e., firm names)
data_grouped <- data %>% group_by(Tick)

# Add a new column "First_price" with the first value of "Close"
data_grouped <- data_grouped %>% mutate(First_price = Close[1])
```
```{r}
data <- data %>% 
  group_by(Tick) %>% 
  mutate(First_price = Close[1],
         New_close = Close / First_price)
```
```{r}
data %>% 
  filter(Tick %in% c("AAPL", "IBM", "MSFT")) %>% 
  ggplot(aes(x = Date, y = New_close, color = Tick)) + 
  geom_line() +
  labs(title = "Normalized Close Price of AAPL, IBM and MSFT",
       x = "Year", y = "Normalized Close Price") +
  scale_color_manual(values = c("blue", "red", "green"))
```

This gives a better idea of the remarkable performance of Apple during the ~22 years of the sample.


### Modifying data: computing **returns**

1) The lag() function is very useful (test this: lag(1:12)). Combining *group_by*() with *mutate*() and *lag*(), create a new column that yields the monthly **Return** of the stocks. **Save** the output because we will need the **Return** column a lot.
2) Select only 3 columns: Tick, Date and return. 
3) With pivot_wider(), create a *wide* version of the returns (i.e. in matrix form), so that each stock return (stock-by-stock) is in a column and each row is a date.      

```{r returns}
cor_mat <- data |>
  group_by(Tick) %>% 
  mutate(Return = Close / lag(Close) - 1) |>
  select(Date, Tick, Return) |>
  pivot_wider(names_from = Tick, values_from = Return) |>
  na.omit()|>
  select(-Date) |>
  cor()
```

Thanks to the grouping, the formula inside **mutate**() is applied sequentially stock-by-stock!   
Don't forget to ungroup()!


### Correlation matrix!

Starting from the output of the previous exercise (continue piping %>%):   
1) Remove the date column and transform the output in a matrix with the function *as.matrix*().   
2) From this, compute the covariance matrix of the first 14 stocks (in alphabetical order). Because of the NAs, you will need the option (argument) use = "complete.obs" in the cor() function.

**Trick**: you can use the *corrplot* or *ggcorrplot* package to visualize this. But you would need to install them first!

```{r correlation}
if(!require(ggcorrplot)){install.packages("ggcorrplot")} # Below, we visualise the correlation matrix using the ggcorrplot package
library(ggcorrplot)
ggcorrplot(cor_mat)
```

Visually, the largest correlations are between **Citigroup** and **Bank of America** and between **Chevron** and **Exxon**, which highlights the importance of the sector for asset co-movements.



***
## PART III: PIVOT TABLES

0) First, we are (again) going to augment the database by adding a **Year** column. The code requires the *lubridate* package:  

```{r date, message = FALSE, warning = FALSE}
if(!require(lubridate)){install.packages("lubridate")} 
# This is a package that handles dates effectively. SKIP this step if already installed.
library(lubridate)
data <- data %>% mutate(Year = year(Date)) # Adding a Year column for yearly statistics.
data
```

1) Group the data by company and by year and create a new variable **Avg_Cap** which computes the average market capitalization.  
2) Plot (with a line) the corresponding results: x-axis is **Year**, y-axis is **Avg_Cap** with one color for each firm. => Hard to read. Beyond 10 firms, the graph becomes less insightful. Try to do the same with a barplot (via *geom_col*()).
3) Pick one year (e.g., 2005) and show the average capitalization of firms in decreasing order.
4) From data, create a pivot table (call it pt for instance) that computes the average capitalization, average P2B and average return for each firm. Hint: for returns, there are some NAs, so use the argument na.rm = T in the mean().  
5) From this outcome use a geom_col to show the average cap of firms.

```{r UP TO YOU! 5, message = F, warning = F}
data |>
  group_by(Tick, Year) %>%
  summarize(Avg_Cap = mean(Mkt_Cap))%>%
  filter(Year == 2010) |>
  arrange(desc(Avg_Cap)) |>
  ggplot(aes(x = Avg_Cap, y = reorder(Tick,Avg_Cap),fill=Avg_Cap)) +  geom_col(alpha = 0.8) + ylab("") + theme_bw() + scale_fill_viridis_c(direction = -1) + theme(legend.position = c(0.7,0.6))
  

```



***
## PART IV: FACTOR ANALYSIS

Research in financial economics has shown that firms' *characteristics* are likely to drive *profitability*. We try to investigate this idea below.  
1) Using data, plot (in a scatter plot, i.e., with points) y = Returns versus x = Mkt_Cap, & add a geom_smooth() layer.    
2) Same exercise but with *pt* (the pivot table from PART III), with x = Avg_Cap and y = Avg_Ret.      
3) Same exercise as 2), but after removing AAPL from the sample. Add a geom_smooth() layer.      
4) From pt, plot x = Avg_P2B and y = Avg_ret. Comment?

```{r UP TO YOU! 6, warning = FALSE, message = FALSE}
install.packages("ggrepel")
library(ggrepel)
```


```{r UP TO YOU! 6, warning = FALSE, message = FALSE}
data %>%
  group_by(Tick) %>%
  mutate(Return = Close/lag(Close)-1) %>%
  summarise(Avg_Return = mean(Return, na.rm = TRUE),
            Avg_Cap = mean(Mkt_Cap, na.rm = TRUE)) %>%
  ggplot(aes(x = Avg_Cap, y = Avg_Return, color = Tick)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(x = "Average Market Capitalization", y = "Average Monthly Return", color = "Stock Ticker")

```


In the last graph, there is an outlier for the average P2B: error in the data? Further investigation would show that in 2017, the book value of Boeing was very small and hence its P2B ratio was extremely high: this is revealed via the global average.     
In the above graphs (omitting AAPL), we see the mild negative relationship between firm size and average return. Though our sample is much too small and our study not rigourous, this resembles the so-called size effect according to which small firms are more profitable than large firms (though not in financial *bad times*).



***
## PART V: LOOPS & FUNCTIONS

"*For*" loops in R work like that:   

for(x in vector){   
  do stuff   
}   

```{r Fibonacci}
a <- c(1,2)
n <- 12
for(i in 3:n){
  a[i] <- a[i-1] + a[i-2]
}
a
```

Now, let's take a vector of dates, many ways to do that:

```{r}
dates <- data$Date %>% 
  as.factor() %>% 
  levels() %>%
  as.Date()       # Creating a vector of dates.
dates <- data %>% 
  filter(Tick == "AAPL") %>% 
  select(Date) %>% 
  as.matrix() %>% # This is to get rid of the dataframe structure to avoid column numbers 
  as.Date()       # Similar though not exactly the same result
dates <- data$Date %>% unique() %>% sort()
```


Initialize a variable to zero (you may call it *Agg_Cap*, for aggregate capitalization).    
Then, create a loop over all dates that computes the aggregate market capitalization summed across all 30 firms at each date (update the variable Agg_Cap: this is a proxy for a market portfolio like the Dow Jones or the S&P500). Plot the corresponding series. It shows the periods of *market turbulence*.     
**Note**: this is a very inefficient way to do this.


```{r UP TO YOU! 7}

```

Now a bit on functions. The syntax is:

```{r}
function_name <- function(argument_1, argument_2){
   z <- argument_1 * argument_2
   return(z)
}

function_name(6,7) # WOW we coded the simple product!
```



## PART VI: PLOTTING THE MARKOWITZ CLOUD

Before we start, a word on the *apply* function. It allows to perform operations on rows (first dimension) or columns (second dimension). We show one example below:  

```{r}
m <- matrix(1:9, nrow = 3) # Sample matrix
m
apply(m, 1, sum) # Sum on rows, dim = 1
apply(m, 2, sum) # Sum on columns, dim = 2
apply(m, 2, max) # Maximum of columns
```


1) Create a returns variable/object with only ticks, dates and returns (use select() and pivot_wider()). You can recycle the code from **Part III**.   
2) Use the na.omit() function to remove missing returns in data.   
3) Using apply, compute the *average (mean)* and *standard deviation* of the columns of this matrix. Save the output into a dataframe or tibble with 3 columns: Tick, avg_return, vol.     
4) From this dataframe/tibble, plot the values on a graph and use ggrepel to annotate (the Tick values).    

```{r r UP TO YOU! 8}

```

You can have a look at the **fPortfolio** package if you want to plot the corresponding efficient frontier.   
**portfolioAnalytics** is also a great package for portfolio construction.

## PART VII: REGRESSIONS & BETAS

Regressions are run as:

```{r}
y <- rnorm(50)                    # Some random series
x <- rexp(50)                     # Another series
data_reg <- data.frame(y,x)
fit <- lm(y ~ x, data = data_reg) # Here is the regression!
summary(fit)
```

What matters (most?) is the coefficients which can be accessed via:   

```{r}
summary(fit)$coef
```

You can also use the great **broom** package: https://cran.r-project.org/web/packages/broom/vignettes/broom.html


1) First, create a market return, which is the average return of all firms, weighted proportionally according to market cap. To do so combine **group_by** and **mutate**! The formula is: sum(Return * Mkt_Cap) / sum(Mkt_Cap)     
Usually, group_by() is combined with summarize(), but it's also super powerful with mutate()!    
The advantage of mutate in this case is that it keeps all rows in the data.

2) Compute the betas of all stocks! You can create a dedicated function that computes the beta... (**HARD**)    
3) Plot them via a geom_col.  
4) You can check that, roughly, on average, the beta is equal to one.

```{r r UP TO YOU! 9}
if(!require(viridis)){install.packages("viridis")} # If you want to change color palettte
library(viridis)

```




***
## PART IX: SUSTAINABLE INVESTING

We end this session with a focus on a topic which is both important gaining traction: **sustainable investing**. Investor are more and more concerned about the impact & footprint of their portfolio holdings.
In our dataset, we have an *ESG_rank* column which represents the ranking score of firms calculated by the firm *Sustainalytics*, on a scale from 0 to 100. We can thus use it for some new computations. However, it is only available from February 2014 onwards. A key question is: whether we pay a financial cost for investing in "**green**" firm.

1) Filter the data to keep only points for the *AAPL* and *MSFT* ticker and for dates **after 2014**. Plot the corresponding *ESG_rank* through time.
2) Filter the data to keep only points after 2014. Then, create a pivot-table that computes *i)* the average return of firms, along with *ii)* their average ESG rank.  
3) Plot the corresponding points with a scatterplot (with ESG as the x-axis). Use a geom_smooth to detect a trend. Conclusion, on this small sample?  
4) **BONUS**: is there a relationship between ESG score and firm size (Mkt_Cap)? You can plot individual points or aggregate values (via a pivot table).

```{r r UP TO YOU! 10}
library(ggplot2)
data_sus <- data %>%
  filter(Tick %in% c("AAPL", "MSFT"), Date >= as.Date("2014-01-01")) 

ggplot(data_sus, aes(Date, ESG_rank, color = Tick)) + 
  geom_line() +
  labs(title = "ESG rank for AAPL and MSFT (after 2014)", x = "Date", y = "ESG rank")

```
```{r}
data_sus2 <- data %>% 
  filter(Date >= as.Date("2014-01-01")) %>% 
  group_by(Tick) %>% 
  summarise((Return = Close / lag(Close) - 1),(Avg_return = mean(Return)), (Avg_ESG = mean(ESG_rank, na.rm = TRUE))

data_sus2

```


```{r}

```

